# -*- sh -*-

# Embedded whitespace is a pain, so all shells compensate by doing magic
# with this literal expression - "$@" - which tells the shell to list all the arguments
# passed into this particular shell function from the command line, single-space-separated,
# and wrap any of the whitespace-containing arguments in (internally escaped) ' '- quotes.

# What's in this resource file that is difficult to deal with mentally, are the various
# games that have to be played with this "$@" technique, to get whitespace cleanly
# carried though to the target machines' command line.  It's not perfect, but workable.

# The key automation principles implemented, are these:

# 1. to use the (hostname tags) naming conventions over configuration (via PCRE "$FILTER"),
# 2. to deal with a consistent inventory (hostname tags) list as a whole via profile mgmt,
# 3. to introduce the basic "batch processing techniques" of ansible with errors (logging),
# 4. to farm out all the profile switching details to ssm_honorlock.sh (as an assoc array),
# 5. to farm out all the AWS ssm session txn management to a small (advanced) ~/.ssh/config,
# 6. introdude conceptual idempotency into the CLI mix.

# All of these principles will factor into the ansible orchestration work to come next.


declare -A AWS_ID

: ${AWS_BATCH:=4} ${AWS_PROFILE:=honorlock}
export AWS_BATCH AWS_PROFILE

function aws_inventory_profile () {
    AWS_PROFILE=${1-honorlock}
    eval "AWS_ID=($(ssm_honorlock.sh | while read host id
           do
               [ "$(basename $SHELL)" = "bash" ] && echo [$host]=$id || echo $host $id
	   done
	  ))"
}

function aws_list_inventory_filter () {
    ([ "$(basename $SHELL)" = "bash" ] && echo "${!AWS_ID[@]}" || echo "${(k)AWS_ID}") \
        | tr ' ' '\n' | sort | grep -Pe "${1-}"
}

function aws_push_ssh_public_key () {
    local FILTER=${1-}
    local pubs="$(cat ~/.ssh/id_*.pub)"

    echo $pubs | grep -q "$USER@" || (
        echo "Invalid Public Key: $USER@ not found in : '$pubs'" >&2 && return 1)

    for host in $(aws_list_inventory_filter "$FILTER")
    do
        (sleep 2; echo 'mkdir -p ~/.ssh'; sleep 1; \
         echo grep "$USER@" '~/.ssh/authorized_keys' '||' \
              echo "$pubs" '>> ~/.ssh/authorized_keys'; sleep 2
        ) | pty ssm_honorlock.sh $host &
    done
    wait
}

function aws_terminal_filter_exec () {
    local FILTER="${1-}"
    shift

    for host in $(aws_list_inventory_filter "$FILTER"); do ssh -t $host "$@"; done
}


function aws_htop_ship_config_filter_bg () {
    local FILTER="${1-}"
    shift

    for host in $(aws_list_inventory_filter "$FILTER")
    do
        ssh $host sudo bash -c \
            '"cat > /home/ssm-user/.config/htop/htoprc"' < ~/.config/htop/htoprc &
    done
    wait
}

function aws_screen_filter_local_shell () {
    local FILTER="${1-}"
    shift

    for host in $(aws_list_inventory_filter "$FILTER")
    do
        screen -X screen $SHELL -c \
               "AWS_PROFILE=$AWS_PROFILE; . ~/.$(basename $SHELL)rc; title $host; ssh -t $host \"\$@\"" -- "$@"
    done
}

function aws_batch_filter_remote_shell () {
    local FILTER=${1-}
    shift

    if isatty 1
    then
        # ANSI color indexes: black = 0, red = 1, green = 2
        # setaf = Set ANSI foreground
        # setab =  "   "   background
        # sgr0  = reset local color adjustments back to default terminal settings
        local errstr="$(tput bold)$(tput setaf 1)$(tput setab 0)error$(tput sgr0)"
        local prefix="$(tput bold)$(tput setaf 2){}$(tput sgr0)"
    else
        local errstr="error"
        local prefix="{}"
    fi

    aws_list_inventory_filter "$FILTER" | xargs -P $AWS_BATCH -i ssh {} sudo -u ubuntu \
        bash -c '"cd /var/www/html && (eval \"\$0\" \
        || echo \"'"$errstr"':\" \"(\"\$0\")\" failed with status code \$?) 2>&1 \
        | while read line; do echo \"'"$prefix"':\" \$line; done"' \""$@"\"
}

aws_inventory_profile $AWS_PROFILE

true
