# -*- sh -*-

declare -A EC2_ID _ec2_linux_price _ec2_windows_price
declare -ax _ec2_hosts _bcs_cmds _bcs_tools
declare -ax _ec2_cmds=(list-inventory ssh-ship-public-key ssm-helper)

export EC2_ID_SRC

# Embedded whitespace is a pain, so all shells compensate by doing magic
# with this literal expression - "$@" - which tells the shell to list all the arguments
# passed into this particular shell function from the command line, single-space-separated,
# and wrap any of the whitespace-containing arguments in (internally escaped) ' '- quotes.

# What's in this resource file that is difficult to deal with mentally, are the various
# games that have to be played with this "$@" technique, to get whitespace cleanly
# carried though to the target machines' command line.  It's not perfect, but workable.

# The key automation principles implemented, are these:

# 1. to use the (Name tags) naming conventions over configuration (via PCRE "$FILTER"),
# 2. to deal with a consistent inventory (Name tags) list as a whole via .bcsrc mgmt,
# 3. to introduce the basic "batch processing techniques" of ansible with errors (logging),
# 4. to farm out all the profile switching details to ec2-ssm-helper.sh (as an assoc array),
# 5. to farm out all the AWS ssm session txn management to a small (advanced) ~/.ssh/config,
# 6. introduce conceptual idempotency into the CLI mix.

_ec2_usage() {
  cat <<EOF
list-inventory             List current ec2 inventory for this AWS role
                           [<args>]
                             1. PCRE ec2 Name (label) filter.

                           ===

ssh-ship-public-key        Ship public key to selected ec2 inventory
                           [<args>]
                             1. PCRE ec2 Name (label) filter.

                           ===

ssm-helper                 Execute installed ~/bin/ec2-ssm-helper.sh script
                           [<args>]
                             1. PCRE ec2 Name (optional).
                           Notes: If executed with no arguments, this will
                           cause ~/bin/ec2-ssm-helper.sh to list the ec2 inventory
                           as a TSV, with a "(host)name => ec2-id" map on each line.
                           Otherwise will launch an ssm terminal (ssm-user login
                           shell) session for the selected ec2 instance.
EOF
}

_ec2_zsh_inventory_hosts_completion() {
  local state
  _arguments '1: :->ec2_host'
  case $state in
    ec2_host)
      _arguments "1:ec2_host:($_ec2_hosts)"
      ;;
  esac
}

_ec2_zsh_completion() {
  local state
  _arguments '1: :->ec2_cmd' '2: :->ec2_host' '*: :->*'

  case $state in
    ec2_cmd)
      _arguments "1:ec2_cmd:($_ec2_cmds $_bcs_cli_cmds)"
      ;;
    ec2_host)
      _arguments "2:ec2_host:($_ec2_hosts)"
      ;;
    *)
      _arguments "*:bin:($(ls ~/bin))"
      ;;
  esac
}

for fcn in "${_bcs_cli_cmds[@]//-/_}" "${_ec2_cmds[@]//-/_}"; do
  if [[ $(basename "$SHELL") == zsh ]]; then
    compdef _ec2_zsh_inventory_hosts_completion ec2_$fcn
    compdef _ec2_zsh_inventory_hosts_completion ec2-${fcn//_/-}.sh
  else
    complete -W '${_ec2_hosts[@]}' ec2_$fcn
    complete -W '${_ec2_hosts[@]}' ec2-${fcn//_/-}.sh
  fi
done

_ec2_load_inventory() {
  [[ -n "${BCS_PROFILE-}" ]] || return 0

  : "${EC2_ID_SRC:=$(
    ec2-ssm-helper.sh | tr -dc "$BCS_ADMISSIBLE_CHARS" | while IFS='	' read -r host id; do
      [[ "$(basename "$SHELL")" == zsh ]] && echo \"$host\" "$id" || echo [$host]="$id"
    done
  )}"
  eval "EC2_ID=( $EC2_ID_SRC )"

  if [[ $(basename "$SHELL") == zsh ]]; then
    eval '_ec2_hosts=("${(k)EC2_ID}")'
  else
    _ec2_hosts=("${!EC2_ID[@]}")
  fi
  return 0
}

ec2_list_inventory() {
  ([[ "$(basename "$SHELL")" == zsh ]] && eval 'echo "${(k)EC2_ID}"' || echo "${!EC2_ID[@]}") |
    tr ' ' '\n' | sort | grep -Pe "${1-}"
}

ec2_ssh_ship_public_key() {
  local FILTER="$1"

  local pubkey="$(grep "$USER@$(hostname)\$" ~/.ssh/id_*.pub | head -n 1)"
  [[ -z "$pubkey" ]] && echo "Can't find your public ssh key for this WSL install!" >&2 && return 1

  for host in $(ec2_list_inventory "$FILTER"); do
    (
      sleep "${DELAY-30}"
      echo 'mkdir -p ~/.ssh'
      sleep 1
      echo grep -q "'$USER@$(hostname)\$'" '~/.ssh/authorized_keys' '||' \
        echo "'$pubkey'" '>> ~/.ssh/authorized_keys'
      sleep 2
    ) | pty -n -- ec2-ssm-helper.sh "$host" &
  done
  wait
}

ec2_shell() {
  local FILTER="$1"
  shift
  [[ $# -gt 0 ]] || set bash
  local TMP
  if ! [[ -t 0 ]]; then
    TMP="$(mktemp /tmp/ec2-XXXX)"
    cat >$TMP
  fi

  for host in $(ec2_list_inventory "$FILTER"); do
    _bcs_title :$host: "$@"
    if [[ -t 0 ]]; then
      ssh -t "$host" sh -c '". ~/.profile 2>/dev/null; eval script.sh -qa /tmp/typescript sudo -Es \"\$@\""' -- "$@"
    else
      bcs_sed_uprobe_shared_libs ssh -t "$host" <$TMP |
        ssh "$host" sh -c '". ~/.profile 2>/dev/null; eval script.sh -qa /tmp/typescript sudo -Es \"\$@\""' -- "$@"
    fi
  done
  local rv=$?

  [[ -f "$TMP" ]] && rm -f $TMP
  return $rv
}

ec2_htop_ship_config_bg() {
  local FILTER="$1"
  shift

  for host in $(ec2_list_inventory "$FILTER"); do
    ssh "$host" sudo sh -c \
      '"mkdir -p /home/ssm-user/.config/htop && cat > /home/ssm-user/.config/htop/htoprc"' <~/.config/htop/htoprc &
  done
  wait
}

ec2_screen() {
  local FILTER="$1"
  shift
  [[ $# -gt 0 ]] || set bash
  local TMP
  if ! [[ -t 0 ]]; then
    TMP="$(mktemp /tmp/ec2-XXXX)"
    cat >$TMP
  fi

  for host in $(ec2_list_inventory "$FILTER"); do
    if [[ -t 0 ]]; then
      screen -X screen "$SHELL" -ic \
        "_bcs_title :$host: \"\$@\"; ssh -t $host sh -lc '\". ~/.profile; eval script.sh -qa /tmp/typescript sudo -Es \\\"\\\$@\\\"\"' -- \"\$@\"" -- "$@"
    else
      bcs_sed_uprobe_shared_libs ssh -t "$host" <$TMP |
        screen -X screen "$SHELL" -ic \
          "_bcs_title :$host: \"\$@\"; ssh -t $host sh -lc '\". ~/.profile; eval script.sh -qa /tmp/typescript sudo -Es \\\"\\\$@\\\"\"' -- \"\$@\"" -- "$@"
    fi
  done
}

ec2_batch() {
  local FILTER="$1"
  shift
  local TMP
  if [[ ! -t 0 ]]; then
    TMP="$(mktemp /tmp/ec2-XXXX)"
    cat >$TMP
  fi

  if [[ -t 1 ]]; then
    # ANSI color indexes: black = 0, red = 1, green = 2
    # setaf = Set ANSI foreground
    # setab =  "   "   background
    # sgr0  = reset local color adjustments back to default terminal settings
    local errstr="$(tput bold)$(tput setaf 1)$(tput setab 0)error$(tput sgr0)"
    local prefix="$(tput bold)$(tput setaf 2){}$(tput sgr0)"
  else
    local errstr="error"
    local prefix="{}"
  fi

  if [[ -t 0 ]]; then
    ec2_list_inventory "$FILTER" | xargs -d '\n' -i echo ssh {} \
      bash -c '"\". ~/.profile; (eval sudo -Es \\\"\\\$@\\\" || echo \\\"'"$errstr"':\\\" \\\(\\\"\\\$@\\\"\\\) failed with status code \\\$? 2>&1) | while read -r line; do echo \\\"'"$prefix"':\\\" \\\$line; done\""' -- '"$@"'
  else
    ec2_list_inventory "$FILTER" | xargs -d '\n' -i echo bcs_sed_uprobe_shared_libs \
      ssh {} '|' ssh {} bash -c '"\". ~/.profile; (eval sudo -Es \\\"\\\$@\\\" || echo \\\"'"$errstr"':\\\" \\\(\\\"\\\$@\\\"\\\) failed with status code \\\$?) 2>&1 | while read -r line; do echo \\\"'"$prefix"':\\\" \\\$line; done\""' -- '"$@"'
  fi |
    xargs -d '\n' -P $BCS_BATCH -i $SHELL -c '. ~/.bcsrc 2>/dev/null; {}' -- "$@"

  local rv=$?
  [ -f "$TMP" ] && rm -f $TMP
  return $rv
}

ec2_tools_ship_bg() {
  local FILTER="$1"

  for host in $(ec2_list_inventory "$FILTER"); do
    for t in "${_bcs_tools[@]}"; do
      ssh $host -- sh -c "'mkdir -p /tmp/bin && cat >/tmp/bin/$t && chmod +x /tmp/bin/$t'" <~/bin/$t &
    done
    ssh $host -- sh -c "'$BCS_REMOTE_PROFILE_CREATION_SCRIPT'" &
    ssh $host -- sh -c '"mkdir -p /tmp/terminfo/x && cat >/tmp/terminfo/x/xterm-256color"' </lib/terminfo/x/xterm-256color &
    ssh $host -- sh -c '"mkdir -p /tmp/terminfo/s && cat >/tmp/terminfo/s/screen.xterm-256color"' </lib/terminfo/s/screen.xterm-256color &
    wait
    echo "Shipped tools to $host."
  done
}

_ec2_load_inventory >/dev/null 2>&1
