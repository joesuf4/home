# -*- sh -*-

# Embedded whitespace is a pain, so all shells compensate by doing magic
# with this literal expression - "$@" - which tells the shell to list all the arguments
# passed into this particular shell function from the command line, single-space-separated,
# and wrap any of the whitespace-containing arguments in (internally escaped) ' '- quotes.

# What's in this resource file that is difficult to deal with mentally, are the various
# games that have to be played with this "$@" technique, to get whitespace cleanly
# carried though to the target machines' command line.  It's not perfect, but workable.

# The key automation principles implemented, are these:

# 1. to use the (Name tags) naming conventions over configuration (via PCRE "$FILTER"),
# 2. to deal with a consistent inventory (Name tags) list as a whole via .bcsrc mgmt,
# 3. to introduce the basic "batch processing techniques" of ansible with errors (logging),
# 4. to farm out all the profile switching details to ssm_honorlock.sh (as an assoc array),
# 5. to farm out all the AWS ssm session txn management to a small (advanced) ~/.ssh/config,
# 6. introduce conceptual idempotency into the CLI mix.

# All of these principles will factor into the ansible orchestration work to come next.

declare -A EC2_ID
declare -ax _ec2_hosts _bcs_cmds _bcs_tools
declare -ax _ec2_cmds=(list-inventory ssh-ship-public-key ssm-helper)

export EC2_ID_SRC

_ec2_usage() {
  cat <<EOF
list-inventory             List current ec2 inventory for this AWS role
                           [<args>]
                             1. PCRE ec2 Name (label) filter.

                           ===

ssh-ship-public-key        Ship public key to selected ec2 inventory
                           [<args>]
                             1. PCRE ec2 Name (label) filter.

                           ===

ssm-helper                 Execute installed ~/bin/ssm-helper.sh script
                           [<args>]
                             1. PCRE ec2 Name (label) (optional).
                           Notes: If executed with no arguments, this will
                           cause ~/bin/ssm-helper.sh to list the ec2 inventory.
                           Otherwise will launch an ssm terminal (shell)
                           session for the selected ec2 instance.
EOF
}

_ec2_zsh_inventory_hosts_completion() {
  local state
  _arguments '1: :->ec2_host'
  case $state in
    ec2_host)
      _arguments "1:ec2_host:($_ec2_hosts)"
      ;;
  esac
}

_ec2_zsh_completion() {
  local state
  _arguments '1: :->ec2_cmd' '2: :->ec2_host' '*: :->*'

  case $state in
    ec2_cmd)
      _arguments "1:ec2_cmd:($_ec2_cmds $_bcs_cli_cmds)"
      ;;
    ec2_host)
      _arguments "2:ec2_host:($_ec2_hosts)"
      ;;
    *)
      _arguments "*:bin:($(ls ~/bin))"
      ;;
  esac
}

for fcn in "${_bcs_cmds[@]//-/_}" "${_ec2_cmds[@]//-/_}"; do
  if [[ $(basename "$SHELL") == zsh ]]; then
    compdef _ec2_zsh_inventory_hosts_completion ec2_$fcn
    compdef _ec2_zsh_inventory_hosts_completion ec2-${fcn//_/-}.sh
  else
    complete -W '${_ec2_hosts[@]}' ec2_$fcn
    complete -W '${_ec2_hosts[@]}' ec2-${fcn//_/-}.sh
  fi
done

_ec2_load_inventory() {
  [[ -n "${BCS_PROFILE-}" ]] || return 0

  : "${EC2_ID_SRC:=$(
    ec2-ssm-helper.sh | tr -dc "$BCS_ADMISSIBLE_CHARS" | while read -r host id; do
      [[ "$(basename "$SHELL")" == zsh ]] && echo "$host" "$id" || echo [$host]="$id"
    done
  )}"
  eval "EC2_ID=( $EC2_ID_SRC )"

  if [[ $(basename "$SHELL") = "zsh" ]]; then
    eval '_ec2_hosts=("${(k)EC2_ID}")'
  else
    _ec2_hosts=("${!EC2_ID[@]}")
  fi
  return 0
}

ec2_list_inventory() {
  ([[ "$(basename "$SHELL")" == zsh ]] && eval 'echo "${(k)EC2_ID}"' || echo "${!EC2_ID[@]}") |
    tr ' ' '\n' | sort | grep -Pe "${1-}"
}

ec2_ssh_ship_public_key() {
  local FILTER=${1-}
  local pubs="$(cat ~/.ssh/id_*.pub)"

  echo "$pubs" | grep -q "$USER@" || (
    echo "Invalid Public Key: $USER@ not found in : '$pubs'" >&2 && return 1
  )

  for host in $(ec2_list_inventory "$FILTER"); do
    (
      sleep "${DELAY-20}"
      echo 'mkdir -p ~/.ssh'
      sleep 1
      echo grep "$USER@" '~/.ssh/authorized_keys' '||' \
        echo "$pubs" '>> ~/.ssh/authorized_keys'
      sleep 2
    ) | pty -n -- ec2-ssm-helper.sh "$host" &
  done
  wait
}

ec2_shell() {
  local FILTER="${1-}"
  shift

  local TMP
  if ! [[ -t 0 ]]; then
    TMP="$(mktemp /tmp/ec2-XXXX)"
    cat >$TMP
  fi

  for host in $(ec2_list_inventory "$FILTER"); do
    _bcs_title :$host: "$@"
    if [[ -t 0 ]]; then
      ssh -t "$host" sh -c '. ~/.profile 2>/dev/null; eval script.sh -qa /tmp/typescript sudo -Es "$@"' -- "$@"
    else
      bcs_sed_uprobe_shared_libs ssh -t "$host" <$TMP |
        ssh "$host" sh -c '. ~/.profile 2>/dev/null; eval script.sh -qa /tmp/typescript sudo -Es "$@"' -- "$@"
    fi
  done

  local rv=$?
  [[ -f "$TMP" ]] && rm -f $TMP
  return $rv
}

ec2_scripts_ship_batch() {
  local FILTER="$1"
  shift
  for script; do
    ec2_batch "$FILTER" "mkdir -p /tmp/bin && cat > /tmp/bin/$script && chmod +x /tmp/bin/$s" <~/bin/"$script"
  done
}

ec2_htop_ship_config_bg() {
  local FILTER="${1-}"
  shift

  for host in $(ec2_list_inventory "$FILTER"); do
    ssh "$host" sudo sh -c \
      '"cat > /home/ssm-user/.config/htop/htoprc"' <~/.config/htop/htoprc &
  done
  wait
}

ec2_bpftrace_ship_kheaders_bg() {
  local FILTER="${1-}"
  local wsl_kernel_version_major="$(uname -r)"
  wsl_kernel_version_major="${wsl_kernel_version_major%.**}"
  for host in $(ec2_list_inventory "$FILTER"); do
    local host_kernel_version_major="$(ssh "$host" uname -r)"
    host_kernel_version_major="${host_kernel_version_major%.**}"
    if [[ ! "$wsl_kernel_version_major" == "$host_kernel_version_major" ]]; then
      echo "Kernel major version mismatch: $(ssh $host -- uname -r) on $host, aborting!" >&2
      continue
    fi
    time ssh $host -- sh -c 'mkdir -p /tmp/kheaders-$(uname -r) && cd /tmp/kheaders-$(uname -r) && tar -xJf -' </sys/kernel/kheaders.tar.xz &
    time ssh host -- sh -c 'mkdir -p /tmp/bin && cat >/tmp/bin/bpftrace && chmod +x /tmp/bin/bpftrace' <~/bin/bpftrace &
    time ssh $host -- sh -c "$BCS_REMOTE_PROFILE_CREATION_SCRIPT" &
    time ssh $host -- sh -c 'mkdir -p /tmp/terminfo/x; cat - >/tmp/terminfo/x/xterm-256color' </lib/terminfo/x/xterm-256color &
    time ssh $host -- sh -c 'mkdir -p /tmp/terminfo/s; cat - >/tmp/terminfo/s/screen.xterm-256color' </lib/terminfo/s/screen.xterm-256color &
    wait
    echo "Sent to $host."
  done
}

ec2_screen() {
  local FILTER="${1-}"
  shift

  for host in $(ec2_list_inventory "$FILTER"); do
    screen "$SHELL" -ic \
      "_bcs_title :$host: \"\$@\"; ssh -t $host sh -lc 'eval script.sh -qa /tmp/typescript sudo -Es \"\$@\"' -- \"\$@\"" -- "$@"
  done
}

ec2_batch() {
  local FILTER="${1-}"
  shift

  if [[ -t 1 ]]; then
    # ANSI color indexes: black = 0, red = 1, green = 2
    # setaf = Set ANSI foreground
    # setab =  "   "   background
    # sgr0  = reset local color adjustments back to default terminal settings
    local errstr="$(tput bold)$(tput setaf 1)$(tput setab 0)error$(tput sgr0)"
    local prefix="$(tput bold)$(tput setaf 2){}$(tput sgr0)"
  else
    local errstr="error"
    local prefix="{}"
  fi

  local TMP
  if [[ ! -t 0 ]]; then
    TMP="$(mktemp /tmp/ec2-XXXX)"
    cat >$TMP
  fi

  if [[ -t 0 ]]; then
    ec2_list_inventory "$FILTER" | xargs -d '\n' -i echo ssh {} \
      sh -lc '"(eval sudo -Es \"\$@\" || echo \"'"$errstr"':\" \"(\"\$@\")\" failed with status code \$?) 2>&1 | while read -r line; do echo \"'"$prefix"':\" \$line; done"' -- '"$@"'
  else
    ec2_list_inventory "$FILTER" | xargs -d '\n' -i echo bcs_sed_uprobe_shared_libs \
      ssh {} '|' ssh {} sh -lc '"(eval sudo -Es \"\$@\" || echo \"'"$errstr"':\" \"(\"\$@\")\" failed with status code \$?) 2>&1 | while read -r line; do echo \"'"$prefix"':\" \$line; done"' -- '"$@"'
  fi |
    xargs -d '\n' -P $BCS_BATCH -i $SHELL -c '. ~/.bcsrc 2>/dev/null; {}' -- "$@"

  local rv=$?
  [ -f "$TMP" ] && rm -f $TMP
  return $rv
}

ec2_ship_tools_bg() {
  local FILTER="${1-}"

  for host in $(ec2_list_inventory "$FILTER"); do
    for t in "${_bcs_tools[@]}"; do
      ssh $host -- sh -c "mkdir -p /tmp/bin && cat >/tmp/bin/$t && chmod +x /tmp/bin/$t" <~/bin/$t &
    done
    ssh $host -- sh -c "$BCS_REMOTE_PROFILE_CREATION_SCRIPT" &
    ssh $host -- sh -c 'mkdir -p /tmp/terminfo/x; cat - >/tmp/terminfo/x/xterm-256color' </lib/terminfo/x/xterm-256color &
    ssh $host -- sh -c 'mkdir -p /tmp/terminfo/s; cat - >/tmp/terminfo/s/screen.xterm-256color' </lib/terminfo/s/screen.xterm-256color &

  done

  wait
}

_ec2_load_inventory >/dev/null 2>&1
