# -*- sh -*-

declare -ax _eks_clusters _eks_nodes _eks_namespaces _eks_pods _bcs_tools _bcs_cmds words
declare -ax _eks_pod_cmds=(list-pods list-pod-containers)
declare -ax _eks_node_cmds=(list-nodes "${_bcs_cli_cmds[@]//#/node-}")
declare -ax _eks_namespace_cmds=(list-namespaces set-namespace)
declare -ax _eks_cluster_cmds=(list-clusters update-kubeconfig)
declare -ax _eks_cmds=("${_eks_pod_cmds[@]}" "${_eks_node_cmds[@]}" "${_eks_namespace_cmds[@]}" "${_eks_cluster_cmds[@]}")
declare -ax _eks_pods_flags=("--selector=")

export EKS_CLUSTERS_SRC EKS_NODES_SRC EKS_NS_SRC EKS_PODS_SRC EKS_POD_SEARCH_LIMIT

: "${EKS_POD_SEARCH_LIMIT:=4}"

_eks_usage() {
  cat <<EOF
list-clusters              Show available AWS kubernetes clusters for the
                           current AWS role

                           ===

update-kubeconfig          Select current kubernetes cluster/context.
                           [<args>]
                             1. Name of cluster
                           Notes: Defaults to currently selected cluster
                           (shown in your xterm window), which effectively
                           reloads the AWS eks config and its pod inventory.

                           ===

list-namespaces            List the available namespaces for this current
                           kubernetes context.
                           [<args>]
                             1. PCRE namespace filter


set-namespace              Set the current context's namespace (updating
                           dependent pod/cluster data)
                           [<args>]
                             1. New namespace

                           ===

list-pods                  List the available pods for this current kubernetes
                           context.
                           [<args>]
                             1. PCRE pod name filter
                           Notes:
                           The pod name filter argument will also accept the
                           following long-flag prefixes (that you can complete
                           yourself):

                               ${_eks_pods_flags[@]}

                           ===

list-pod-containers        List the available containers for the given pod
                           filter.
                           [<args>]
                             1. PCRE pod name filter (see "list-pods" note)
                             2. PCRE container name filter

EOF
}

_eks_zsh_clusters_completion() {
  local state

  _arguments '1: :->eks_cluster'

  case $state in
    eks_cluster)
      _arguments "1:eks_cluster:($_eks_clusters)"
      ;;
  esac
}

_eks_zsh_pod_container_completion() {
  local state

  _arguments '1: :->eks_pod' '2: :->eks_container'

  case $state in
    eks_pod)
      _arguments "1:eks_pod:($_eks_pods)"
      ;;
    eks_container)
      compadd "$@" $(eks_list_pod_containers "${words[2]}")
      ;;
  esac
}

_eks_zsh_completion() {
  local state
  _arguments '1: :->eks_cmd' '2: :->eks_pod' '3: :->eks_container' '*: :->*'

  case $state in
    eks_cmd)
      _arguments "1:eks_cmd:($_eks_cmds $_bcs_cli_cmds)"
      ;;
    eks_pod)
      if [[ "${words[2]}" == list-clusters || "${words[2]}" == update-kubeconfig ]]; then
        _arguments "2:eks_cluster:($_eks_clusters)"
      elif [[ "${words[2]}" == list-namespaces || "${words[2]}" == set-namespace ]]; then
        _arguments "2:eks_namespace:($_eks_namespaces)"
      elif [[ "${words[2]}" != "${words[2]#node-}" ]]; then
        _arguments "2:eks_node:($_eks_nodes)"
      else
        _arguments "2:eks_pod:($_eks_pods)"
      fi
      ;;
    eks_container)
      if [[ "${words[2]}" != "${words[2]#node-}" ]]; then
        _arguments "3:bin:($(ls ~/bin))"
      else
        _arguments "3:eks_container:($(eks_list_pod_containers "${words[3]}"))"
      fi
      ;;
    *)
      _arguments "*:bin:($(ls ~/bin))"
      ;;
  esac
}

for fcn in "${_eks_cluster_cmds[@]//-/_}"; do
  if [[ "$(basename "$SHELL")" == zsh ]]; then
    compdef _eks_zsh_clusters_completion eks_$fcn
  else
    complete -W '${_eks_clusters[@]}' eks_$fcn
  fi
done

for fcn in "${_bcs_cmds[@]//-/_}" "${_eks_pod_cmds[@]//-/_}"; do
  if [[ "$(basename "$SHELL")" == zsh ]]; then
    compdef _eks_zsh_pod_container_completion eks_$fcn
  else
    complete -W '${_eks_pods[@]}' eks_$fcn
  fi
done

eks_list_clusters() {
  local FILTER="${1-}"
  for c in "${_eks_clusters[@]}"; do echo "$c"; done | grep -Pe "$FILTER"
}

eks_list_namespaces() {
  local FILTER="${1-}"
  for c in "${_eks_namespaces[@]}"; do echo "$c"; done | grep -Pe "$FILTER"
}

eks_list_pods() {
  local FILTER="${1-}"
  if [[ ! "${FILTER}" == "${FILTER#--}" ]]; then
    local EKS_PODS_SRC
    local _eks_pods
    _eks_load_pods "$FILTER"
    FILTER=""
  fi
  for c in "${_eks_pods[@]}"; do
    [[ "$c" == "${c#--}" ]] && echo "$c"
  done | grep -Pe "$FILTER"
}

eks_list_nodes() {
  local FILTER="${1-}"
  for c in "${_eks_nodes[@]}"; do echo "$c"; done | grep -Pe "$FILTER"
}

eks_list_pod_containers() {
  local PFILTER="${1-}"
  local CFILTER="${2-}"

  set $(eks_list_pods "$PFILTER")
  if [[ $# -le $EKS_POD_SEARCH_LIMIT ]]; then
    for pod; do
      for c in $(kubectl get pod $pod -o jsonpath="{.spec.containers[].name}"); do
        echo "$c"
      done
    done
  else
    for c in $(kubectl get pods -o jsonpath="{..spec.containers[].name}"); do
      echo "$c"
    done
  fi |
    grep -Pe "$CFILTER" | sort | uniq
}

_eks_load_clusters() {
  [[ -n "$BCS_PROFILE" ]] || return 0
  : "${EKS_CLUSTERS_SRC:=$(aws eks list-clusters --output text | awk '{print $2}' | tr -dc "$BCS_ADMISSIBLE_CHARS")}"
  eval "_eks_clusters=($EKS_CLUSTERS_SRC)"
  EKS_NS_SRC=
  EKS_NODES_SRC=
  EKS_PODS_SRC=
  return 0
}

_eks_load_nodes() {
  [[ -n "$BCS_PROFILE" ]] || return 0
  : "${EKS_NODES_SRC:=$(kubectl get nodes | (
    read -r _
    awk '{print $1}' | tr -dc "$BCS_ADMISSIBLE_CHARS"
  ))}"
  eval "_eks_nodes=($EKS_NODES_SRC)"
  return 0
}

_eks_load_namespaces() {
  [[ -n "$BCS_PROFILE" ]] || return 0
  : "${EKS_NS_SRC:=$(kubectl get namespaces --field-selector=status.phase=Active | (
    read -r _
    awk '{print $1}' | tr -dc "$BCS_ADMISSIBLE_CHARS"
  ))}"
  eval "_eks_namespaces=($EKS_NS_SRC)"
  return 0
}

_eks_load_pods() {
  [[ -n "$BCS_PROFILE" ]] || return 0
  : "${EKS_PODS_SRC:=$(kubectl get pods "$@" --field-selector=status.phase=Running | (
    read -r _
    awk '{print $1}' | tr -dc "$BCS_ADMISSIBLE_CHARS"
  )) ${_eks_pods_flags[@]}}"
  eval "_eks_pods=($EKS_PODS_SRC)"
  return 0
}

eks_update_kubeconfig() {
  [[ $# -gt 0 ]] || set "$(kubectl config get-contexts | awk '/^\*/ { print $2 }' | cut -d/ -f2)"
  aws eks update-kubeconfig --name "$1"
  EKS_NODES_SRC=
  EKS_PODS_SRC=
  EKS_NS_SRC=
  _eks_load_nodes
  _eks_load_namespaces
  _eks_load_pods
}

eks_set_namespace() {
  [[ $# -gt 0 ]] || set "$(kubectl config --current-context get-namespaces | awk '/^\*/ { print $2 }' | cut -d/ -f2)"
  kubectl config set-context --current --namespace="${1-default}"
  EKS_PODS_SRC=
  _eks_load_pods
}

eks_tools_ship_bg() {
  local FILTER="${1-}"
  local container="${2-}"
  [[ "$container" == "--" ]] && container=""

  for pod in $(eks_list_pods "$FILTER"); do
    for c in $(eks_list_pod_containers "^\\Q$pod\\E\$" "$container"); do
      for t in "${_bcs_tools[@]}"; do
        time kubectl exec -i $pod -c $c -- sh -c "mkdir -p /tmp/bin && cat >/tmp/bin/$t && chmod +x /tmp/bin/$t" <~/bin/$t &
      done
      kubectl exec $pod -c $c -- sh -c "$BCS_REMOTE_PROFILE_CREATION_SCRIPT" &
      kubectl exec $pod -c $c -- sh -c 'mkdir -p /tmp/terminfo/x; cat - >/tmp/terminfo/x/xterm-256color' </lib/terminfo/x/xterm-256color &
      kubectl exec $pod -c $c -- sh -c 'mkdir -p /tmp/terminfo/s; cat - >/tmp/terminfo/s/screen.xterm-256color' </lib/terminfo/s/screen.xterm-256color &
      wait
      echo "Shipped ${stype-tools} to $pod/$c."
    done
  done
}

eks_node_tools_ship_bg() {
  local NFILTER="${1-}"

  for node in $(eks_list_nodes "$NFILTER"); do
    for t in "${_bcs_tools[@]}"; do
      time kubectl node-shell $node -- sh -c "mkdir -p /tmp/bin && cat >/tmp/bin/$t && chmod +x /tmp/bin/$t" <~/bin/$t
    done
    kubectl node-shell $node -- sh -c "$BCS_REMOTE_PROFILE_CREATION_SCRIPT"
    kubectl node-shell $node -- sh -c 'mkdir -p /tmp/terminfo/x; cat - >/tmp/terminfo/x/xterm-256color' </lib/terminfo/x/xterm-256color
    kubectl node-shell $node -- sh -c 'mkdir -p /tmp/terminfo/s; cat - >/tmp/terminfo/s/screen.xterm-256color' </lib/terminfo/s/screen.xterm-256color
    echo "Shipped ${stype-tools} to $node."
  done
}

eks_scripts_ship_batch() {
  local PFILTER="$1"
  local CFILTER="$2"
  shift
  shift
  for script; do
    eks_batch "$PFILTER" "$CFILTER" "mkdir -p /tmp/bin && cat > /tmp/bin/$script && chmod +x /tmp/bin/$script" <~/bin/"$script"
  done
}

eks_node_scripts_ship_batch() {
  local NFILTER="$1"
  shift
  for script; do
    BCS_BATCH=1 eks_node_batch "$NFILTER" "mkdir -p /tmp/bin && cat > /tmp/bin/$script && chmod +x /tmp/bin/$script" <~/bin/"$script"
  done
}

eks_bpftrace_ship_kheaders_bg() {
  local FILTER="${1-}"
  local container="${2-}"
  [[ "$container" == "--" ]] && container=""
  local wsl_kernel_version_major="$(uname -r)"
  wsl_kernel_version_major="${wsl_kernel_version_major%.**}"

  for pod in $(eks_list_pods "$FILTER"); do
    for c in $(eks_list_pod_containers "^\\Q$pod\\E\$" "$container"); do
      if ! kubectl exec $pod -c $c -- sh -c 'uname -r | grep -E "^$wsl_kernel_version_major[.]" \
      || (echo "Kernel major version mismatch $(uname -r): on $pod/$c, aborting!">&2 && false)'; then
        continue
      fi
      time kubectl exec -i $pod -c $c -- sh -c 'mkdir -p /tmp/kheaders-$(uname -r) && cd /tmp/kheaders-$(uname -r) && tar -xJf -' </sys/kernel/kheaders.tar.xz &
      time kubectl exec -i $pod -c $c -- sh -c 'mkdir -p /tmp/bin && cat >/tmp/bin/bpftrace && chmod +x /tmp/bin/bpftrace' <~/bin/bpftrace &
      kubectl exec $pod -c $c -- sh -c "$BCS_REMOTE_PROFILE_CREATION_SCRIPT" &
      kubectl exec $pod -c $c -- sh -c 'mkdir -p /tmp/terminfo/x; cat - >/tmp/terminfo/x/xterm-256color' </lib/terminfo/x/xterm-256color &
      kubectl exec $pod -c $c -- sh -c 'mkdir -p /tmp/terminfo/s; cat - >/tmp/terminfo/s/screen.xterm-256color' </lib/terminfo/s/screen.xterm-256color &
      wait
    done
  done
}

eks_node_bpftrace_ship_kheaders_bg() {
  local NFILTER="${1-}"
  local wsl_kernel_version_major="$(uname -r)"
  wsl_kernel_version_major="${wsl_kernel_version_major%.**}"

  for node in $(eks_list_nodes "$NFILTER"); do
    if ! kubectl node-shell $node -- sh -c 'uname -r | grep -E "^$wsl_kernel_version_major[.]" \
      || (echo "Kernel major version mismatch $(uname -r): on $node, aborting!">&2 && false)'; then
      continue
    fi
    time kubectl node-shell -i $node -- sh -c 'mkdir -p /tmp/kheaders-$(uname -r) && cd /tmp/kheaders-$(uname -r) && tar -xJf -' </sys/kernel/kheaders.tar.xz
    time kubectl node-shell $node -- sh -c 'mkdir -p /tmp/bin && cat >/tmp/bin/bpftrace && chmod +x /tmp/bin/bpftrace' <~/bin/bpftrace
      kubectl node-shell $node -- sh -c "$BCS_REMOTE_PROFILE_CREATION_SCRIPT"
      kubectl node-shell $node -- sh -c 'mkdir -p /tmp/terminfo/x; cat - >/tmp/terminfo/x/xterm-256color' </lib/terminfo/x/xterm-256color
      kubectl node-shell $node -- sh -c 'mkdir -p /tmp/terminfo/s; cat - >/tmp/terminfo/s/screen.xterm-256color' </lib/terminfo/s/screen.xterm-256color
  done
}

eks_shell() {
  local FILTER="$1"
  local container="${2-}"
  shift
  [[ $# -gt 0 ]] && shift
  [[ "$container" == "--" ]] && container=""

  local TMP
  if [[ ! -t 0 ]]; then
    TMP="$(mktemp /tmp/eks-XXXX)"
    cat >$TMP
  fi

  for pod in $(eks_list_pods "$FILTER"); do
    for c in $(eks_list_pod_containers "^\\Q$pod\\E\$" "$container"); do
      _bcs_title :$pod/$c: "$@"
      if [[ -t 0 ]]; then
        kubectl exec -ti $pod -c $c -- sh -lc '[ -x /usr/bin/sudo ] && sudo ="sudo -Es"; eval script.sh -qa /tmp/typescript $sudo "$@"' -- "$@"
      else
        bcs_sed_uprobe_shared_libs kubectl exec $pod -c $c -- <$TMP | kubectl exec -i $pod -c $c -- sh -lc '[ -x /usr/bin/sudo ] && sudo="sudo -Es"; eval script.sh -qa /tmp/typescript $sudo "$@"' -- "$@"
      fi
    done
  done

  local rv=$?
  [[ -f "$TMP" ]] && rm -f $TMP
  return $rv
}

eks_node_shell() {
  local NFILTER="${1-}"
  shift
  [[ $# -eq 0 ]] && set bash
  local TMP
  if [[ ! -t 0 ]]; then
    TMP="$(mktemp /tmp/eks-XXXX)"
    cat >$TMP
  fi

  for node in $(eks_list_nodes "$NFILTER"); do
    _bcs_title :$node: "$@"
    if [[ -t 0 ]]; then
      kubectl node-shell $node -- sh -lc '[ -x /usr/bin/sudo ] && sudo ="sudo -Es"; eval script.sh -qa /tmp/typescript $sudo "$@"' -- "$@"
    else
      bcs_sed_uprobe_shared_libs kubectl node-shell $node -- <$TMP | kubectl exec node-shell $node -- sh -lc '[ -x /usr/bin/sudo ] && sudo="sudo -Es"; eval script.sh -qa /tmp/typescript $sudo "$@"' -- "$@"
    fi
  done

  local rv=$?
  [[ -f "$TMP" ]] && rm -f $TMP
  return $rv
}

eks_htop_ship_config_bg() {
  local FILTER="$1"
  local container="${2-}"
  shift
  [[ $# -gt 0 ]] && shift
  [[ "$container" == "--" ]] && container=""

  for pod in $(eks_list_pods "$FILTER"); do
    for c in $(eks_list_pod_containers "^\\Q$pod\\E\$" "$container"); do
      kubectl exec -i $pod -c $c -- sh -c \
        '[ -x /usr/bin/sudo ] && sudo="sudo -Es"; $sudo sh -c "mkdir -p ~/.config/htop && cat > ~/.config/htop/htoprc"' <~/.config/htop/htoprc &
    done
  done
  wait
}

eks_node_htop_ship_config_bg() {
  local NFILTER="${1-}"

  for node in $(eks_list_nodes "$NFILTER"); do
    kubectl node-shell $node -- sh -c \
        '[ -x /usr/bin/sudo ] && sudo="sudo -Es"; $sudo sh -c "mkdir -p ~/.config/htop && cat > ~/.config/htop/htoprc"' <~/.config/htop/htoprc
  done
  wait
}

eks_screen() {
  local FILTER="$1"
  local container="${2-}"
  shift
  [[ $# -gt 0 ]] && shift
  [[ "$container" == "--" ]] && container=""

  for pod in $(eks_list_pods "$FILTER"); do
    for c in $(eks_list_pod_containers "^\\Q$pod\\E\$" "$container"); do
      screen "$SHELL" -ic \
        "_bcs_title :$pod/$c: \"\$@\"; kubectl exec -ti $pod -c $c -- sh -lc '[ -x /usr/bin/sudo ] && sudo =\"sudo -Es\"; eval script.sh -qa /tmp/typescript \$sudo \"\$@\"' -- \"\$@\"" -- "$@"
    done
  done
}

eks_node_screen() {
  local NFILTER="${1-}"
  shift

  for node in $(eks_list_nodes "$NFILTER"); do
    screen "$SHELL" -ic \
        "_bcs_title :$node: \"\$@\"; kubectl node-shell $node -- sh -lc '[ -x /usr/bin/sudo ] && sudo =\"sudo -Es\"; eval script.sh -qa /tmp/typescript \$sudo \"\$@\"' -- \"\$@\"" -- "$@"
    sleep 5
  done
}

function eks_node_batch() {
  local NFILTER="$1"
  shift

  if [[ -t 1 ]]; then
    # ANSI color indexes: black = 0, red = 1, green = 2, cyan = 6
    # setaf = Set ANSI foreground
    # setab =  "   "   background
    # sgr0  = reset local color adjustments back to default terminal settings
    local errstr="$(tput bold)$(tput setaf 1)$(tput setab 0)error$(tput sgr0)"
    local prefix='$(tput bold)$(tput setaf 2)$pod$(tput sgr0)/$(tput setaf 6)$c$(tput sgr0)'
  else
    local errstr="error"
    local prefix='$pod/$c'
  fi

  local TMP
  if [[ ! -t 0 ]]; then
    TMP="$(mktemp /tmp/eks-XXXX)"
    cat >$TMP
  fi

  for nodes in $(eks_list_nodes "$NFILTER"); do
    if [[ -t 0 ]]; then
      echo kubectl node-shell $node -- \
          sh -lc '"([ -x /usr/bin/sudo ] && sudo=\"sudo -Es\"; eval \$sudo \"\$@\" || echo \"'"$errstr"':\" \"(\"\$@\")\" failed with status code \$?) 2>&1 | while read -r line; do echo \"'"$(eval "echo \"$prefix\"")"':\" \$line; done"' -- '"$@"'
    else
      echo bcs_sed_uprobe_shared_libs kubectl node-shell $node -- "<$TMP" '|' kubectl node-shell $node -- \
          sh -lc '"([ -x /usr/bin/sudo ] && sudo=\"sudo -Es\"; eval \$sudo \"\$@\" || echo \"'"$errstr"':\" \"(\"\$@\")\" failed with status code \$?) 2>&1 | while read -r line; do echo \"'"$(eval "echo \"$prefix\"")"':\" \$line; done"' -- '"$@"'
    fi
  done |
    xargs -d '\n' -P $BCS_BATCH -i $SHELL -c '. ~/.bcsrc 2>/dev/null; {}' -- "$@"

  local rv=$?
  [[ -f "$TMP" ]] && rm -f $TMP
  return $rv
}

_eks_load_clusters >/dev/null 2>&1
_eks_load_nodes >/dev/null 2>&1
_eks_load_namespaces >/dev/null 2>&1
_eks_load_pods >/dev/null 2>&1
